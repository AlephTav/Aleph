Обработка и перехват ошибок
===========================



Фрэймворк предоставляет возможность перехвата ошибок или исключений в коде, а
также предоставляет средства для получения исчерпывающей информации об этих
ошибках.

Перехват ошибок фрэймворком включается на этапе его инициализации. Вы также
можете отключить его при необходимости или установить требуемый уровень
чувствительности к ошибкам:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Выключаем перехват ошибок и исключений.
Aleph::errorHandling(false);
// Включаем перехват ошибок и исключений,
// а также задаём чувствительность к ошибкам.
Aleph::errorHandling(true, E_ALL & ~E_NOTICE);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

По умолчанию уровень чувствительности к ошибкам равен E_ALL.

Проверить включён ли перхват ошибок фрэймворком можно вызвав метод
**isErrorHandlingEnabled**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
echo (int)Aleph::isErrorHandlingEnabled();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Метод вернёт TRUE, если перехват включён и FALSE в противном случае.

Как отмечалось ранее в главе 3, фрэймворк поддреживает режим отладки при котором
выводится исчерпывающая информация о возникшей ошибке или исключении. Управляет
этим режимом булевый конфигурационный параметр **debugging**. По умолчанию
значение этого параметра FALSE.

Информацию об ошибке или исключении фрэймворк получает при помощи статического
метода **analyzeException** класса **\Aleph**. Этот метод принимает в качестве
единственного параметра объект класса **\Exception**, а возвращает ассоциативный
массив с полной информацией об этом исключении.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
print_r(Aleph::analyzeException(new RuntimeException('Error Message')));
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для того чтобы выбросить исключение применяется метод **exception**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Aleph::exception(new LogicException('Error Message'));
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Отличие этого метода от оператора **throw** в том, что он работает во всех
магических методах php. Например, вы не можете выбрасывать исключение в
магическом методе **__toString**, однако с помощью метода **exception** это
становится возможным:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
...
public function __toString()
{
  try
  {
    return $this->build();
  }
  catch (\Exception $e)
  {
    \Aleph::exception($e);
  }
}
...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Класс Aleph\\Core\\Exception и сообщения об ошибках
---------------------------------------------------



Во фрэймворке принято соглашение по поводу формирования и размещения сообщений
об ошибках генерируемых самим фрэймворком. Тексты всех сообщений об ошибках
фрэймворка хранятся в виде констант классов генерирующих эти сообщения. Базовый
класс **\Aleph** хранит общие сообщения об ошибках.

Название константы определяющий шаблон сообщения об ошибке должно следовать
следующему патерну ERR_{имя класса}_{номер шаблона}. Само название константы
называется токеном ошибки.

Шаблоны ошибок могут содержать заменяемые последовательности символов называемые
переменными шаблона. Переменные шаблона обозначаются как "[{var}]". Для
формирования законченного сообщения об ошибке служит статический метод **error**
класса **\Aleph**.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Класс содержащий шаблоны сообщений об ошибках.
class Foo
{
  const ERR_FOO_1 = 'My [{var}] error [{var}]';
  ...
}

// Формируем сообщение об ошибке по её токену.
echo Aleph::error('Foo::ERR_FOO_1', 'first', 'test');
// Получим сообщение 'My first error test (Token: Foo::ERR_FOO_1)'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для выбрасывания исключений с сообщениями в стиле фрэймворка предназначен класс
**Aleph\Core\Exception**. Аргументы конструктора класса подобны аргументам
метода **error**. Также с помощью этого класса вы можете легко идентифицировать
ошибку и получить информацию о ней.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Определяем класс выкидывающий исключение.
class Foo
{
  const ERR_FOO_1 = '[{var}] error message';

  // Метод выбрасывающий исключение.
  public function run()
  {
    throw new Core\Exception($this, 'ERR_FOO_1', 'My');
  }
  
  ...
}

// Выбрасываем исключение и затем перехватываем его.
try
{
  (new Foo())->run();
}
catch (Core\Exception $e)
{
  // Получаем название класса ошибки.
  echo 'Class: ' . $e->getClass();
  // Получаем название токена ошибки.
  echo 'Token: ' . $e->getToken();
  // Получаем информацию об ошибке.
  print_r($e->getInfo());
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Собственный обработчик ошибок
-----------------------------



Существует возможность определить собственный обработчик ошибок. Для этого
предназначена конфигурационная переменная **customDebugMethod**. Значением этой
переменной является делегат, вызываемый при возникновении какой-либо ошибки или
исключении. В качестве параметра делегат принимает объект исключения и
информацию о нём.

Делегат должен возвращать булевое значение. Если это значение TRUE, то
дальнейшая обработка ошибки будет проводиться фрэймворком. В противном случае
обработка ошибки является задачей делегата.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Устанавливаем свой обработчик ошибок.
\Aleph::getInstance()['customDebugMethod'] = $handler;

// Определяем обработчик.
$handler = function(\Exception $e, array $info)
{
  echo $e->getMessage();
  // Запрещаем дальнейшую обработку ошибки.
  return false;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>   Обратите внимание, что пользовательский обработчик ошибок может быть вызван
>   только если перехват ошибок фрэймворком разрешён (метод
>   **Aleph::isErrorHandlingEnabled** возвращает TRUE). В противном случае вам
>   необходимо его включить при помощи метода **Aleph::errorHandling**.

Кроме установки своего собственного обработчика ошибки фрэймворк позволяет
указать свой шаблон для вывода информации об ошибке в режиме отладки
(**debugging** равен TRUE) или задать шаблон для выдачи сообщения о факте
возникновения ошибки в продакшн режиме (**debugging** равен FALSE). Для этих
целей служат соответственно конфигурационный свойства **templateDebug** и
**templateBug**.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$a = Aleph::getInstance();
// Определяем путь к файлу шаблона ошибки для режима отладки.
$a['templateDebug'] = '/path/to/new/debug/template';
// Определяем путь к файлу шаблона ошибки для продакшн режима.
$a['templateBug'] = '/path/to/new/bug/template';
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>   Если шаблоны ошибок не определенны, то будут использоваться шаблоны по
>   умолчанию. Эти шаблоны находятся в константах **Aleph::TEMPLATE_DEBUG** и
>   **Aleph::TEMPLATE_BUG** соответственно.



Логирование ошибок
------------------



За логирование возникающих ошибок отвечает конфигурационный параметр
**logging**. Если этот булевый параметр равен TRUE, то информация об ошибках и
исключениях будет сохраняться в лог-файлах. Директория этих файлов определяется
в конфигурационной переменной **dirs** под алиасом **logs**.

Вы также можете хранить в логах и любую другую информацию. Пример записи данных
в лог файл:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Aleph::log(['foo' => 'some data']);
Aleph::log('another data');
Aleph::log(new MyClass());
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Названия файлов лога будут сгенерированны автоматически. Просмотреть содержимое
лог-файлов вы сможете в конфигураторе.

Как и в случае с обработчиком ошибок вы можете определить свой логер ошибок.
Делегат определяющий пользовательский логер ошибок задаётся в конфигурационном
свойстве **customLogMethod**. В качестве единственного параметра делегат
принимает массив с информацией об ошибке.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Устанавливаем свою функцию логера ошибок.
Aleph::getInstance()['customLogMethod'] = $logger;

// Определяем функцию логинга.
$handler = function(array $info)
{
  ...
  // Сохраняем информацию об ошибке
  ...
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
