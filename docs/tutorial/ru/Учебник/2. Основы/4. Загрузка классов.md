Загрузка классов
================



Фрэймворк Aleph использует механизм автозагрузки неопределённых классов,
интерфейсов или трэйтов. При этом не требуется следования какому-либо соглашению
об именовании классов или их файлов. Вы можете задать любое название файлу с
классом и разместить его в директории с любым именем, и он всё равно будет
найден и подключен к вашему скрипту автоматически.

По этой же причине становиться возможным легко использовать классы сторонних
разработчиков. Для этого достаточно разместить файлы классов в любой директории
проекта. Никаких дополнительных действий в коде не требуется.

Работа загрузчика классов основана на поиске классов в файлах проекта. Когда в с
крипте встречается какой-либо неопределённый класс, интерфейс или трэйт,
загрузчик выполняет поиск всех классов в разрешённых директориях и файлах, после
чего размещает информацию о местоположении найденных классов в файле
**classmap.php** (находящегося в корневой директории сайта) в виде
ассоциативного массива. Ключами этого массива являются названия классов, а
значениями - полные пути к файлам этих классов. Загрузчик становится активным во
время инициализации фрэймворка (метод **init** класса **\Aleph**).



Конфигурирование загрузчика классов
-----------------------------------



Существует ряд методов класса **\Aleph** позволяющих гибко управлять подгрузкой
классов. Например, вы можете получить массив всех путей к файлам с классами или
задать свою карту путей:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Инициализируем фрэймворк и получаем экземпляр класса Aleph.
$a = Aleph::init();
// Получаем массив путей к файлам с классами.
print_r($a->getClasses());
// Устанавливаем свой массив путей полностью заменяя существующий.
$a->setClasses(['foo\myclass1' => '/path/to/class1',
                'foo\myclass2' => '/path/to/class2',
                'foo\myclass3' => '/path/to/class3', ...]);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>   Обратите внимание, что названия классов должны быть заданы в нижнем
>   регистре.

По умолчанию загрузчик ищет классы в корневой директории сайта и во всех её
поддиректориях. Но что делать если необходимо подключать классы из других
директорий, например, из директории которая находится за пределами корневой
директории сайта. В таких случаях следует явно указать директории в которых
следует осуществлять поиск классов:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Инициализируем фрэймворк и получаем экземпляр класса Aleph.
$a = Aleph::init();
// Задаём директории для поиска классов.
$a->setDirectories(['/path/to/directory1' => false,
                    '/path/to/directory2' => false,
                    '/path/to/directory3' => true, ...]);
// Получаем список директорий для поиска.
print_r($a->getDirectories());
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для каждой директории можно указать, следует ли искать классы в её
поддиректориях или нет. За это отвечают булевые параметры, являющиеся значениями
массива директорий. Поиск в поддиректориях соотвествует значению TRUE.

Вы также можете определить в каких именно файлах следует искать классы. Это
можно сделать установив регулярное выражение для имени файлов. Только файлы, чьи
имена будут соответствовать этому регулярному выражению, будут включены в поиск
классов.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Инициализируем фрэймворк и получаем экземпляр класса Aleph.
$a = Aleph::init();
// Установка маски (регулярного выражения) имени файла.
$a->setMask('.+\.(php|html|inc)$');
// Чтение текущей маски.
echo $a->getMask();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

По умолчанию маска имени файлов определяется как "/.+\\.php\$/i". Т.е. классы
ищутся лишь в файлах с расширением php.

Если возникла необходимость убрать из поиска какой-либо определённый файл или
файлы (или директории), то вы легко можете это сделать:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Инициализируем фрэймворк и получаем экземпляр класса Aleph.
$a = Aleph::init();
// Задаём исключения для файлов и папок.
$a->setExclusions(['/my/file1', '/my/file2', '/my/directory', ...]);
// Получаем установленные исключения.
print_r($a->getExclusions());
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Кроме тех файлов или директорий, которые вы определили самостоятельно, фрэймворк
не включает в поиск директории .hg, .git и .svn



Ручная загрузка классов
-----------------------



При необходимости вы можете подключить какой-либо класс вручную:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Инициализируем фрэймворк и получаем экземпляр класса Aleph.
$a = Aleph::init();
// Подключаем класс My\Namespace\Class.
$a->load('My\Namespace\Class');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если такой класс существует, то метод **load** вернёт TRUE. В противном случае
загрузчик классов попытается найти требуемый класс. В случае если ему это не
удасться сделать метод вернёт FALSE.

Если вызвать метод **load** без параметров, то загрузчик выполнит поиск всех
классов в заданных директориях, перезаписав информацию в кэше:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Инициализируем фрэймворк и получаем экземпляр класса Aleph.
$a = Aleph::init();
// Ищем классы.
echo 'Found classes: ' . $a->load();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом случае метод возвращает количество найденных классов.

В некоторых случаях может возникнуть необходимость изменения логики загрузчика
классов. Для этого во фрэймворке предусмотрена возможность задания своей функции
автозагрузки. Под функцией автозагрузки понимается некоторый делегат, который
будет вызываться всякий раз когда интерпритатор php встретит неопределённый
класс,  интерфейс или трэйт. В делегат будут переданы два параметра: имя
подключаемого класса и массив всех путей к файлам с классами, возвращаемый
методом **getClasses**. В задачу делегата будет входить подключение файла с
требуемым классом, либо выдача ошибки о том, что класс не найден.

Следующий пример демонстрирует определение пользовательского метода автозагрузки
классов. В этом методе класс **Foo** подменяется на фиктивный объект (этот
подход может быть использован, например, при создании моков объектов в
unit-тестировании).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Инициализируем фрэймворк и получаем экземпляр класса Aleph.
$a = Aleph::init();
// Устанавливаем собственный автозагрузчик.
$a->setAutoload('loader');

...

// Определяем функцию автозагрузки классов.
function loader($class, array $classes)
{
  // Заменяем класс Foo на фиктивный.
  if ($class == 'Foo') eval('class Foo {}');
  // Остальные классы подключаем стандартным способом.
  Aleph::getInstance()->load($class);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

С помощью метода **getAutoload** можно получить делегат автозагрузки.

>   Метод **setAutoload** не изменяет сам механизм автозагрузки классов
>   (основанный на их поиске). Он лишь позволяет определить собственный способ
>   добавления классов в скрипт или рекцию на подключение несуществующих
>   классов.
