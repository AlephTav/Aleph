Маршрутизатор
=============



Для маршрутизации запросов во фрэймворке применяется класс **Aleph\Net\Router**.
Этот класс связывает регулярные выражения (шаблоны) соотвествующие URL текущего
запроса с каким либо действием, заданным в форме делегата. Помимо шаблона URL
класс также позволяет установить для каких HTTP-методов выполнять те или иные
действия.

Класс маршрутизатора используется POM и API модулями.



URL шаблоны
-----------



URL шаблоны представляют собой надмножество perl-совместимых регулярных
выражений, в которых некоторые символы имеют специальное значение:

-   Символ #. Используется для выделения некоторой части URL в переменную.
    Например, шаблон `category/#category#/#ID#` будет соотвествовать следующим
    URL:

    -   category/my_first_category/5

    -   category/my_second_category/10

    -   category/my_third_category/15

    -   ...

    При этом, переменной category будут соотвествовать значения:
    my_first_category, my_second_category, my_third_category и т.д. А переменной
    ID значения: 5, 10, 15 и т.д.

    Если требуется использовать символ # без специального значения, то вам нужно
    экранировать его с помощью обратного слэша:
    `category/#category#/#ID#\#fragment`.

-   Символ |. Используется для задания регулярного выражения для переменной
    шаблона. Например, если мы хотим ограничить переменную ID из предыдущего
    примера только целыми числами, то мы можем написать такое регулярное
    выражение: `category/#category#/#ID|[0-9]+#`. Если после символа |
    встретится ещё один такой символ, то он будет трактоваться как обычный
    символ альтернативы в регулярных выражениях.



Связывание делегатов с шаблонами
--------------------------------



Связать некоторый шаблон URL с произвольным делегатом можно при помощи метода
**bind**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
$router->bind('/add/#a#/#b#', 'MyClass->foo', 'GET|POST');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В данном примере URL-шаблон `/add/#a#/#b#` будет связан с делегатом
`MyClass->foo`. Причём эта связь будет работать только, если HTTP-метод текущего
запроса GET или POST. Когда делегат будет вызван в качестве параметров ему будут
переданны значения переменных iшаблона `#a#` и `#b#`.

Помимо метода **bind** есть ещё два метода, позволяющие осуществлять редирект
при совпадении URL текущего запроса с заданным шаблоном.

Следующий метод производит редирект по указанному адресу:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
$router->redirect('/articles/#article#', '/posts/#article#', 'GET');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Первый параметр метода - шаблон URL для сопоставления. Второй параметр - URL для
редиректа. Причём вы можете использовать в нём переменный шаблона для замены
части URL. Например, для примеры выше. Запрос с URL вида
`/articles/route_engine` приведёт к редиректу на адрес `/posts/route_engine`.

Метод **redirect** имеет также четвёртый параметр, определяющий делегат, который
будет вызван вместо редиректа по указанному адресу. В качестве параметра
делегату будет передан полностью сформированный URL для редиректа. Пример:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Создаём наш метод, который просто выводит URL для редиректа.
$redirect = function($url)
{
  return $url;
}

// Создаём объект маршрутизатора.
$router = new Router();
// Связываем шаблон с действием.
$router->redirect('/articles/#article#', '/posts/#article#', 'GET', $redirect);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

С помощью метода **secure** вы можете осуществлять смену HTTP протокола на HTTPS
и наоборот, согласно шаблону URL. Например, мы хотим чтобы для всех URL
содержащих путь `/secure/` происходил редирект на тот же самый адрес но уже с
протоколом https. В этом случае код может быть таким:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
$router->secure('.+/secure/.+', true, 'GET|POST|PUT|DELETE');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Второй параметр метода определяет тип протокола. Если он равен TRUE, то редирект
приведёт к смене текущего протокола на HTTPS. В противном случае, редирект
меняет протокол на HTTP.

>   Редиректа не произойдёт, если текущий протокол соответствует требуемому.

Третий параметр определяет HTTP метод или методы, для которых следует выполнить
сопоставление с URL-шаблоном.

Также как и в случае с методом **redirect** метод **secure** принимает в
качестве четвёртого параметра делегат, который будет вызван вместо самого
редиректа. Делегату будет передан URL для перехода.



Дополнительные параметры маршрутизации
--------------------------------------




