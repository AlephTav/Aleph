Маршрутизатор
=============



Для маршрутизации запросов во фрэймворке применяется класс **Aleph\Net\Router**.
Этот класс связывает регулярные выражения (шаблоны) соотвествующие URL текущего
запроса с каким либо действием, заданным в форме делегата. Помимо шаблона URL
класс также позволяет установить для каких HTTP-методов выполнять те или иные
действия.

Класс маршрутизатора используется POM и API модулями.



URL шаблоны
-----------



URL шаблоны представляют собой надмножество perl-совместимых регулярных
выражений, в которых некоторые символы имеют специальное значение:

-   Символ #. Используется для выделения некоторой части URL в переменную.
    Например, шаблон `category/#category#/#ID#` будет соотвествовать следующим
    URL:

    -   category/my_first_category/5

    -   category/my_second_category/10

    -   category/my_third_category/15

    -   ...

    При этом, переменной category будут соотвествовать значения:
    my_first_category, my_second_category, my_third_category и т.д. А переменной
    ID значения: 5, 10, 15 и т.д.

    Если требуется использовать символ # без специального значения, то вам нужно
    экранировать его с помощью обратного слэша:
    `category/#category#/#ID#\#fragment`.

-   Символ |. Используется для задания регулярного выражения для переменной
    шаблона. Например, если мы хотим ограничить переменную ID из предыдущего
    примера только целыми числами, то мы можем написать такое регулярное
    выражение: `category/#category#/#ID|[0-9]+#`. Если после символа |
    встретится ещё один такой символ, то он будет трактоваться как обычный
    символ альтернативы в регулярных выражениях.



Связывание делегатов с шаблонами
--------------------------------



Связать некоторый шаблон URL с произвольным делегатом можно при помощи метода
**bind**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
$router->bind('add/#a#/#b#', 'MyClass->foo', 'GET|POST');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В данном примере URL-шаблон `/add/#a#/#b#` будет связан с делегатом
`MyClass->foo`. Причём эта связь будет работать только, если HTTP-метод текущего
запроса GET или POST. Когда делегат будет вызван в качестве параметров ему будут
переданны значения переменных iшаблона `#a#` и `#b#`.

Помимо метода **bind** есть ещё два метода, позволяющие осуществлять редирект
при совпадении URL текущего запроса с заданным шаблоном.

Следующий метод производит редирект по указанному адресу:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
$router->redirect('articles/#article#', '/posts/#article#', 'GET');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Первый параметр метода - шаблон URL для сопоставления. Второй параметр - URL для
редиректа. Причём вы можете использовать в нём переменный шаблона для замены
части URL. Например, для примеры выше. Запрос с URL вида
`/articles/route_engine` приведёт к редиректу на адрес `/posts/route_engine`.

Метод **redirect** имеет также четвёртый параметр, определяющий делегат, который
будет вызван вместо редиректа по указанному адресу. В качестве параметра
делегату будет передан полностью сформированный URL для редиректа. Пример:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Создаём наш метод, который просто выводит URL для редиректа.
$redirect = function($url)
{
  return $url;
}

// Создаём объект маршрутизатора.
$router = new Router();
// Связываем шаблон с действием.
$router->redirect('articles/#article#', '/posts/#article#', 'GET', $redirect);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

С помощью метода **secure** вы можете осуществлять смену HTTP протокола на HTTPS
и наоборот, согласно шаблону URL. Например, мы хотим чтобы для всех URL
содержащих путь `/secure/` происходил редирект на тот же самый адрес но уже с
протоколом https. В этом случае код может быть таким:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
$router->secure('#.+/secure/.+#i', true, 'GET|POST|PUT|DELETE');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>   Обратите внимание, что первый параметр метода это обычное perl-совместимое
>   регулярное выражение.

Второй параметр метода определяет тип протокола. Если он равен TRUE, то редирект
приведёт к смене текущего протокола на HTTPS. В противном случае, редирект
меняет протокол на HTTP.

>   Редиректа не произойдёт, если текущий протокол соответствует требуемому.

Третий параметр определяет HTTP метод или методы, для которых следует выполнить
сопоставление с URL-шаблоном.

Также как и в случае с методом **redirect** метод **secure** принимает в
качестве четвёртого параметра делегат, который будет вызван вместо самого
редиректа. Делегату будет передан URL для перехода.



Дополнительные параметры маршрутизации
--------------------------------------



Кроме указания HTTP-методов, вы также можете задать некоторые другие
дополнительные опции влияющие на маршрутизацию. Во-первых, с помощью метода
**component** вы сможете указать какую часть URL текущего запроса следует
использовать для сопоставления с URL-шаблоном.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
// Связываем некоторое действие с URL-шаблоном.
$router->bind('my.host.(com|net|org)/posts/#post#', 'MyClass->foo', 'GET|POST')
// Определяем какую часть URL следует сопоставлять с шаблоном.
       ->component(URL::HOST | URL::PATH);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Параметр метода **component** это число соотвествующее некоторой константе
класса URL или их комбинации. Каждая такая константа соответствует определённой
части URL. Вот полный список констант:

-   **ALL** - соотвествует целому URL.

-   **SCHEME** - соответствует схеме URL.

-   **HOST** - соответствует хосту.

-   **PATH** - путь URL.

-   **QUERY** - запрос URL.

-   **FRAGMENT** - фрагмент URL.

>   Обратите внимание, что почти все методы класса **Aleph\Net\Router**
>   возвращают объект этого же класса. Это значит, что вы можете вызывать
>   несколько методов цепочкой (fluent interface), делая ваш код более читаемым.

Следующий метод позволяет определить регулярное выражение применяемое к
некоторой переменной шаблона.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
// Связываем некоторое действие с URL-шаблоном.
$router->bind('posts/#post#', 'MyClass->foo', 'GET|POST')
// Задаём регулярное выражение для переменной шаблона post.
       ->validation('/^[a-zA-Z0-9_]+$/i');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Вы также можете задавать регулярные выражения для переменных шаблона
непосредственно в самом шаблоне URL. Однако преимущество метод **validation**
состоит в том, что мы можем задавать сколь угодно сложные регулярные выражения
не засоряя основной URL-шаблон.

Когда делегат, ассоциированный с некоторым URL-шаблоном, будет вызван, ему в
качестве параметров будут переданны значения переменных шаблона. Для передачи
дополнительных параметров делегату предназначен метод **args**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
// Связываем некоторое действие с URL-шаблоном.
$router->bind('posts/#post#', 'MyClass->foo', 'GET|POST')
// Определяем дополнительные параметры делегата.
       ->args(['arg1' => 'val1', 'arg2' => 'val2']);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>   Заметьте, что если название переменной шаблона совпадает с названием
>   дополнительного параметра, то при перадачи параметров в делегат будет взято
>   значение переменной шаблона.

Названия переменных шаблона по умолчанию не соответствуют названиям переменных
делегата. Однако с помощью метода **coordinateParameterNames** в сможете
потребовать соотвествие названий аргументов делегата названиям переменных
шаблона. Делается это так:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
// Связываем некоторое действие с URL-шаблоном.
$router->bind('posts/#post#', 'MyClass->foo', 'GET|POST')
// Включаем синхронизацию с аргументами делегата.
       ->coordinateParameterNames();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Иногда удобней передавать переменные шаблона в виде ассоциативного массива в
качестве одного из аргументов делегата. Это можно сделать при помощи метода
**extra**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
// Связываем некоторое действие с URL-шаблоном.
$router->bind('posts/#post#', 'MyClass->foo', 'GET|POST')
// Зададим название параметра делегата,
// в который будут переданы переменные шаблона в виде ассоциативного массива.
       ->extra('foo');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

А что происходит, когда сопадение с шаблоном найдено, но делегат не может быть
вызван (например не существует требуемого класса или метода). По умолчанию, в
этом случае возникает исключение. Однако с помощью метода
**ignoreWrongDelegate** мы можем отключить выбрасывание исключений. В таком
случае, если делегат не может быть вызван, происходит переход к следующему
шаблону URL.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
// Связываем некоторое действие с URL-шаблоном.
$router->bind('posts/#post#', 'MyClass->foo', 'GET|POST')
// Включаем пропуск невалидных делегатов.
       ->ignoreWrongDelegate();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Маршрутизация
-------------



После того как все шаблоны определены можно осуществить маршрутизацию запроса.
Для это предназначен метод **route**.

Первым параметром метод принимает HTTP-метод или методы, для которых следует
осуществить маршрутизацию. Если этот параметр неопределён, то будет
использоваться HTTP-метод текущего запроса.

Второй параметр - это строка URL (или объект класса **Aleph\Net\URL**), которая
будет анализироваться на предмет совпадения с шаблонами URL. Если этот параметр
не задан, то будет взят URL текущего запроса.

Пример маршрутизации текущего запроса к серверу:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$router = new Router();
// Устанавливаем редирект на защищённый протокол для некоторых URL.
$router->secure('#.+/admin.+#i', true, '*');
// Устанавливаем редирект для определённого URL.
$router->redirect('article/#article#', '/posts/#article#', 'GET');
// Связываем делегаты с шаблонами.
$router->bind('category/#category#', 'MyClass->getCategory', 'GET|POST')
       ->args(['type' => 'general']);
$router->bind('posts/#post#', 'MyClass->getPost', 'GET|POST')
       ->ignoreWrongDelegate()
       ->extra('params');
// Собственно маршрутизация.
$router->route();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Метод **route** возвращает массив вида `['success' => ..., 'result' => ...]`.
Где первый элемент информирует нас о том было (значение TRUE) или нет (значение
FALSE) совпадение с шаблоном. Если совпадение было, то второй элемент массива
содержит результат вызова делегата.
