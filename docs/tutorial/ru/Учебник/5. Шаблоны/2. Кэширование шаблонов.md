Кэширование шаблонов
====================



Результат обрабтки любого шаблона может быть закэширован. Вы можете включить
кэширование шаблона двумя способами:

1.  Через дополнительные параметры конструктора:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    $tpl = new Template('/path/to/template', 3600, 'TCID', new Cache\Memory());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Второй параметр конструктора определяет время кэширования шаблона,
    выраженное в секундах. Третий параметр - уникальный идентификатор кэша
    шаблона.

    >   Если идентификатор не задан, то в качестве него будет взят md5 от самого
    >   шаблона. Однако такой подход не обеспечит 100% гарантии отсутствия
    >   коллизий. Поэтому рекомендуется явно указывать идентификатор кэша.

    Четвёртый необязательный параметр конструктора - объект кэширования. По
    умолчанию будет использоваться внутренний кэш фрэймворка.

2.  Через вызовы соответствующих методов класса шаблонизатора:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Создаём объект шаблонизатора.
    $tpl = new Template('/path/to/template', 3600);
    // Устанавливаем объект кэширования.
    $tpl->setCache(new Cache\File());
    // Устанавливаем идентификатор кэша.
    $tpl->setCacheID('TCID');
    // Устанавливаем срок кэширования.
    $tpl->setExpirationTime(600);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Проверить существования кэша шаблона можно так:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if ($tpl->isExpired()) // кэш просрочен
else // кэш существует
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Кэширование вложенных шаблонов
------------------------------



Поскольку переменными шаблонов могут быть объекты любых типов данных, то мы
можем в качестве них указывать объекты шаблонизаторов, создавая тем самым
шаблоны любого уровня вложенности. Эти вложенные шаблоны также могут быть
закэшированны.

Предположим что у нас есть два шаблона. Основной шаблон:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Common Template: <?=rand(0, 1000000);?>
<?=$subTemplate;?>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

И шаблон, который будет вложен в основной:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sub Template: <?=rand(0, 1000000);?>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Создадим объект кэширования и добавим в переменную `$subTemplate` объект
шаблонизатора подшаблона. Главный шаблон будем кэшировать на 10 секунд, а
подшаблон на 5.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Создаём объект шаблонизатора главного шаблона.
$tpl = new Template('/path/to/first/template', 10, 'tpl1');
// Добавляем шаблонизатор для подшаблона.
$tpl->subTemplate = new Template('/path/to/second/template', 5, 'tpl2');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Теперь вызовем метод **render** для главного шаблона. Допустим, мы получили
следующий результат:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Common Template: 35678
Sub Template: 732213
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Последующие вызовы будут возвращать ту же самую картину в течении близжайших 5
секунд. После истечения 5 секунд кэш подшаблона будет сброшен и шаблон будет
обработан во второй раз. При этом кэш главного шаблона всё ещё существует. И
значит результат вызова метода **render** главного шаблонизатора по истечении 5
секунд будет например таким.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Common Template: 35678
Sub Template: 18342
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Таким образом, кэширование подшаблона никак не связанно с кэшированием внешнего
шаблона, и наоборот.
