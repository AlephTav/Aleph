Делегаты
========



Понятие делегата является одним из ключевых понятий фрэймворка Aleph. Делегат
является дальнейшим развитием **callable** объектов php (смотри более подробно
[тут][1]), предоставляя более широкие возможности по предоставлению ссылок на
функции или методы классов.

В общем случае делегат можно представить как строковое представление вызова
некоторой функции или метода класса. Делегатом также является объект класса
**Aleph\Core\Delegate**. Объекты этого класса являются **callable**. Это значит
вы можете обращаться с ними как с функциями. При этом в реальности будет вызвана
функция или метод класса на который ссылкается делегат. Другими словами делегат
это своего рода алиас некоторой функции или метода класса.

Конструктор класса делегата принимает единственный аргумент - ссылку на
**callable** объект, которая может быть значением любого типа. Вот несколько
примеров задания делегатов для ссылки нестрокового типа:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Предположим у нас есть методы некоторого класса
// для которых мы хотим задать делегаты.
class Test
{
  public static function a() {...}

  public function b($p1, $p2) {...}
}

// Создаём делегат метода "a".
$d1 = new Delegate(['Test', 'a']);
// Создаём делегат для метода "b".
$d2 = new Delegate([new Test, 'b']);
// А этот делегат ссылается на конструктор класса.
$d3 = new Delegate(new Test);
// Мы также можем ссылаться на другие делегаты.
$d4 = new Delegate($d3);
// Делегат на анонимную функцию.
$d5 = new Delegate(function() {...});

// Теперь мы можем вызвать делегируемы методы.
// Вызываем метод "a".
$d1();
// Вызываем метод "b".
$d2(1, 2);
// Вызываем конструктор класса "Test".
// Делегат вернёт нам объект этого класса.
$test = $d3(); // то же самое что и $test = $d4();
// Вызываем анонимную функцию.
$d5();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Строковые ссылки позволяют более гибко связывать делегат с функцией или методом
класса.

Существует 7 основных типов строковых ссылок:

1.  **function** - вызов функции.

2.  **class::method** - вызов статического метода класса.

3.  **class->method** - вызов нестатического метода класса. Класс имеет пустой
    конструктор.

4.  **class[]** - вызов пустого конструктора класса.

5.  **class[n]** - вызов конструктора класса принимающего **n** параметров.

6.  **class[n]->method** - вызов нестатического метода класса. Конструктор
    класса принимает **n** параметров.

7.  **class@cid->method** - вызов нестатического метода веб-контрола.

Здесь **function** - название функции, **class** - название класса, **method** -
название метода класса, **n** - число параметров конструктора класса, **cid** -
уникальный или логический идентификатор веб-контрола.

Помимо перечисленных основных видов строк делегата существует два случая
контекстно зависимых делегатов:

-   **::method** - если определён страничный класс (переменная
    `Aleph\MVC\Page::$page`), то такой делегат аналогичен вызову
    соответствующего статического метода страничного класса. Если же страничный
    класс не определён, то будет вызван сответствующий метод класса **Aleph**.

-   **->method** - аналогично первому случаю, только применительно к
    нестатическим методам.

Несколько поясняющих примеров:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Определяем класс методы которого будут делегироваться.
class Test
{
  public static function a() {...} 

  public function __construct($p1, $p2) {...}

  public function b($p) {...}
}

// Обычная функция.
function c($p1, $p2 = null) {...}

// Создаём делегат метода "a".
$d1 = new Delegate('Test::a');
// Создаём делегат на метод "b".
$d2 = new Delegate('Test[2]->b');
// Создаём делегат конструктора класса.
$d3 = new Delegate('Test[2]');
// Создаём делегат функции "c".
$d4 = new Delegate('c');

// Вызываем метод "a".
$d1();
// Вызываем метод "b".
// При этом первые два параметра передаются в конструктор класса,
// третий параметр передаётся в метод.
$d2('a', 'b', 'foo');
// Вызываем конструктор класса и получаем объект.
$test = $d3('a', 'b');
// Вызываем функцию.
$d4('a');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Иногда бывает удобней передавать параметры делегату в виде массива. Вы можете
сделать это с помощью метода **call**. Вызовы делегатов из примера выше в этом
случае будут выглядеть так:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Вызываем метод "a".
$d1->call();
// Вызываем метод "b".
// При этом первые два параметра передаются в конструктор класса,
// третий параметр передаётся в метод.
$d2->call(['a', 'b', 'foo']);
// Вызываем конструктор класса и получаем объект.
$test = $d3->call(['a', 'b']);
// Вызываем функцию.
$d4->call(['a']);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Каждый объект делегата может быть легко преобразован в своё строковое
представление:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Создаём делегат.
$d = new Delegate([new Test('a', 'b'), 'foo']);
// Получаем строкове представление делегата.
echo (string)$d; // выведет Test[2]->foo
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Это преобразование является обратимым (т.е. вы сможете использовать строковое
представление делегата в качестве ссылки на функцию или метод) за исключением
случая, если делегат ссылается на замыкание.

Класс **Aleph** имеет статический метод позволяющий одновременно создавать и
вызывать делегат:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Aleph::delegate('Test[1]->foo', 'a', 1, 2);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Получение информации о делегате
-------------------------------



После создания делегата вы можете получить различного рода информацию о нём.
Например, вы можете проверить сможет ли делегируемая функция или метод класса
быть вызванными, т.е. существует ли сама функция, класс или его метод:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Создаём делегат.
$d = new Delegate('Test->foo');
// Проверяем возможность вызова делегата.
echo (int)$d->isCallable();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Метод **isCallable** возвращает TRUE, если нет никаких препятствий для вызова
делегата и FALSE в противном случае. Также этот метод принимает булевый параметр
(по умолчанию TRUE), отвечающий за автоподгрузку класса делегата.

Существует также несколько методов возвращающих информацию о типе делегата,
название делегируемого класса или метода:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Создаём делегат.
$d = new Delegate('Test[1]->foo');
// Получаем название класса делегата.
echo $d->getClass();
// Получаем название метода (или функции) делегата.
echo $d->getMethod();
// Получаем название типа делегата.
// Возможные значения: "closure", "function", "class" или "control".
echo $d->getType();
// Получаем полную информацию о делегате.
print_r($d->getInfo());
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В некоторых случаях может понадобиться получить объект делегируемого класса или
параметры делегируемой функции или метода. Для этого предусмотренны
соответствующие методы делегата:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Создаём делегат.
$d = new Delegate('Test[2]->foo');
// Получаем объект класса Test.
// В конструктор класса передаём два параметра.
$test = $d->getClassObject(['a', 'b']);
// Получаем массив параметров метода foo.
$params = $d->getParameters();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Разрешения делегата
-------------------



Часто возникает необходимость проверить принадлежит ли делегат указанному
пространству имён, классу или конкретному методу класса. Такая проверка нужна, в
частности, в системе контролов, для того чтобы запретить вызовы произвольных
делегатов, инициируемые на стороне клиента.

Чтобы проверить принадлежность делегата одному или нескольким разрешениям
необходимо воспользоваться методом **in**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Создаём делегат.
$d = new Delegate('Aleph\Utils\Test[2]->foo');
// Проверяем вхождение делегата в пространство имён Aleph.
echo (int)$d->in('Aleph\\');
// Проверяем вхождение делегата в пространство имён Aleph\Utils.
echo (int)$d->in('Aleph\Utils\\');
// Проверяем вхождение делегата в класс Aleph\Utils\Test
echo (int)$d->in('Aleph\Utils\Test');
// Проверяем соответствие делегата методу foo класса Test.
echo (int)$d->in('Aleph\Utils\Test->foo');
// Проверяем принадлежность делегата пространству имён Aleph
// или классу Foo\MyClass.
echo (int)$d->in(['Aleph\\', 'Foo\MyClass']);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Во всех этих случаях метод **in** вернёт TRUE.

>   Обратите внимание, что название пространства имён должны заканчиваться
>   символом обратного слэша "\\". В противном случае метод воспримет его как
>   название класса.

[1]: <http://www.php.net/manual/en/language.types.callable.php>
