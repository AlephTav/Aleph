Кэширование данных
==================



Каждому типу кэша соотвествует свой класс фрэймворка. Все эти классы
унаследованны от одного общего абстрактного класса **Aleph\Cache\Cache** и
поэтому наследуют единый интерфейс работы с кэшем.



Основные операции
-----------------



К основным операциям работы с кэшем относятся: проверка доступности кэширования
заданного типа, запись данных в кэш, чтение из кэша, удаление данных из кэша,
отчистка кэша.

Для определения доступности кэша требуемого типа предназначен статический метод
**isAvailable**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Проверяем доступность файлового кэша 
// (всегда возвращает TRUE). 
echo (int)Cache\File::isAvailable();
// Проверка доступности кэша APC.
echo (int)Cache\APC::isAvailable();
// Проверка доступности кэша Memcache.
echo (int)Cache\Memory::isAvailable();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Добавление данных в кэш, получение данных, удаление данных, а также их проверка
на существование, осуществляется следующим образом:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Добавляем данные в кэш на 1 час.
// Сохраняемым данным присваиваем идентификатор foo.
$cache->set('foo', 'some data', 3600);
// Чтение данных из кэша.
echo $cache->get('foo');
// Проверяем существуют ли ещё данные в кэше
if (!$cache->isExpired('foo'))
{
  // Если данные существуют удаляем их.
  $cache->remove('foo');
}
// Удаляем все данные из кэша.
$cache->clean();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>   Для файлового кэша метод **get** будет всегда возвращать ранее записанные
>   данные, даже если срок их хранения истёк. Для удаления просроченных данных
>   используйте метод **gc**.

Базовый класс **Aleph\Cache\Cache** реализует перегрузку свойств и интерфейс
ArrayAccess. Это значит, что вы можете обращаться к кэшируемым данным как
свойствам класса или элементам массива:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Чтение данных ассоциированных с идентификатором "foo".
echo $cache->foo;
// Эквивалентый вариант.
echo $cache['foo'];
// Удаление данных из кэша.
unset($cache->foo);
// Или так
unset($cache['foo']);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В случае с добавлением данных в кэш через эти интерфейсы дело обстоит сложнее.
Если в кэше уже есть данные с таким же идентификатором, то данные будут
обновлены, при этом группа и время их хранения останутся прежними. Если же
указанный идентификатор не ассоциирован ни с какими данными, то будет
использована группа по умолчанию и время хранения таких данных станет равном
максимально возможному для данного типа кэша. Следующий пример поясняет
вышесказанное:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Первый раз добавляем данные в кэш, 
// время их жизни равно максимальному времени жизни для данного типа кэша
// используется группа по умолчанию.
$cache['foo'] = 'some data';
// Добавляем данные в кэш обычным способом в группу "test" на 10 секунд. 
$cache->set('foo', 'some data', 10, 'test');
// Изменяем данные, при этом время жизни и группа не меняются.
$cache->foo = 'some data';

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Группы
------



Существует возможность ассоциировать данные помещаемые в кэш с некоторым
идентификатором (помимо уникального идентификатора данных) называемом группой. В
кэше могут храниться множество разнородных данных обладающих общей группой.

Для групп предусмотренны операции получения и удаления данных:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Добавляем числа от 1 до 10 в группу "test" на 1 минуту.
foreach (range(1, 10) as $n) $cache->set('var' . $n, $n, 60, 'test');
// Получаем все данные группы "test" в виде ассоциативного массива.
print_r($cache->getByGroup('test'));
// Удаляем все данные из группы "test".
$cache->cleanByGroup('test');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Когда при добавлении данных в кэш вы не указываете группу, то создаётся группа
по умолчанию с пустым именем. Вы также можете получать или удалять данные из
этой дефолтной группы:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Получаем все данные группы по умолчанию.
print_r($cache->getByGroup());
// Удаляем все данные из дефолтной группы.
$cache->cleanByGroup();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтобы получить список всех групп и идентификаторов данных связанных с ними
достаточно вызвать соответствующий метод:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
print_r($cache->getVault());
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
