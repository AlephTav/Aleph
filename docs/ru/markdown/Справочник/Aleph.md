# Aleph #

## Общая информация ##

|                     |               |
| ------------------- | ------------- |
| **Наследование**    | нет           |
| **Дочерние классы** | нет           |
| **Интерфейсы**      | ArrayAccess   |
| **Файл**            | lib/Aleph.php |

Класс **Aleph** реализует базовый функционал фрэймворка:
- Перехват и обработку ошибок.
- Ленивую загрузку классов.
- Конфигурирование приложения.
- Реализацию шаблона проектирования Registry.
- Простейшие средства логирования и профилирования.

Кроме перечисленной функциональности **Aleph** предоставляет несколько дополнительных методов, которые могут быть полезны при разработке любого веб приложения.

## Общедоступные статические методы ##

### Основные методы

Они могут быть использованы для получения различной информации и выполнения часто возникающих операций.

### **init()**

```php
public static self init(string $root)
```

||||
| --- | --- | --- |
| **$root** | string | корневая директория сайта. |

Инициализация фрйэмворка. Возвращает объект класса **Aleph**. Если **$root** не установлен, то будет использовано значение переменной **$_SERVER['DOCUMENT_ROOT']**. Если же и переменная **$_SERVER['DOCUMENT_ROOT']** не установлена, то в качестве корневой директории сайта будет взята директория файла **aleph.php**. 


### **getInstance()**

```php
public static self getInstance()
```

Возвращает экземпляр класса **Aleph**, или NULL, если фрйэмворк не проинициализирован (метод **init()** не был вызван).

### **getRoot()**

```php
public static string getRoot()
```

Возвращает полный путь к корневой директории сайта (DOCUMENT_ROOT). Если фрэймворк не проинициализирован метод возвращает NULL.

### **getSiteUniqueID()**

```php
public static string getSiteUniqueID()
```

Возвращает уникальный идентификатор приложения. Этот идентификатор определяется как md5 от корневой директории сайта.

### **setOutput()**

```php
public static void setOutput(string $output)
```

||||
| ----------- | ------ | ------------ |
| **$output** | string | тело ответа. |

Устанавливает тело ответа сервера. Вся информация переданная в выходной буфер через стандартные операции ввода/вывода будет игнорироваться.

### **getOutput()**

```php
public static string getOutput()
```

Возвращает ранее заданное тело ответа сервера.

### **exe()**

```php
public static string exe(string $code, array $vars = null)
```

||||
| --------- | ------ | ------------------------------------------------------------------- |
| **$code** | string | PHP код для выполнения.                                             |
| **$vars** | array  | ассоциативный массив переменных, которые будут извлечены в PHP код. |

Выполняет заданный PHP код посредством оператора **eval** и возвращает результат выполнения. 

### **dir()**

```php
public static string dir(string $dir)
```

||||
| -------- | ------ | ------------------------------------- |
| **$dir** | string | путь к директории сайта или её алиас. |

Возвращает полный путь к директории сайта. Значениями **$dir** могут быть:
- полный путь к директории сайта;
- путь к директории сайта относительно корневой директории сайта;
- псевдоним (алиас) директории определённый в конфигурационном файле сайта в секции **dirs**.

### **url()**

```php
public static string url(string $url)
```

||||
| -------- | ------ | ---------------------------------- |
| **$url** | string | URL директории сайта или её алиас. |

Возвращает URL директории сайта. Значениями **$url** могут быть:
- URL директории сайта;
- путь к директории сайта относительно корневой директории сайта;
- псевдоним (алиас) директории определённый в конфигурационном файле сайта в секции **dirs**.

### **log()**

```php
public static void log(mixed $data)
```

||||
| --------- | ----- | ----------------------------- |
| **$data** | mixed | любые данные для логирования. |

Записывает данные в файл лога. Помимо данных переданных в метод, в лог записывается дополнительная информация об окружении (IP адрес, ID сессии, URL запроса к странице, метка времени, содержимое сессии, кукисов и т.д.).

### **go()**

```php
public static void go(string $url, boolean $inNewWindow = false, boolean $immediately = true)
```

||||
| -------- | ------ | ------------------ |
| **$url** | string | URL для редиректа. |
| **$inNewWindow** | boolean | определяет следует ли открыть ссылку в новом окне. |
| **$immediately** | boolean | определяет произойдёт ли переход немедленно и скрипт будет остановлен по завершению вызова метода. |

Осуществляет переход на определённый адрес. Если второй параметр метода TRUE, то ссылка будет открыта в новом окне. В противном случае переход произойдёт в текущем окне браузера. Третий параметр метода позволяет сделать отложенный переход, если он равен FALSE. В этом случае скрипт не завершает свою работу сразу после вызова метода и переход происходит только после полного завершения работы скрипта.

### **reload()**

```php
public static void reload(boolean $immediately = true)
```

||||
| ---------------- |-------- | ------------------------------------------------------------------------------------------------------------ |
| **$immediately** | boolean | определяет произойдёт ли перезагрузка немедленно и скрипт будет остановлен по завершению вызова метода. |

Перезагружает сраницу. Если параметр равен FALSE, скрипт продолжит свою работу после вызова метода и перезагрузка произойдёт только после окончания его работы. В противном случае (параметр равен TRUE) скрипт завершает свою работу после вызова метода и перезагрузка происходит немедленно. 

### **delegate()**

```php
public static mixed delegate(mixed $callback, mixed $arg1, mixed $arg2, ...)
```

||||
| ------------- | ----- | ----------------------------------------------------------- |
| **$callback** | mixed | строка делегата, объект делегата или любой callable объект. |
| **$arg1**, **$arg2**, ... | mixed | аргументы функции обратного вызова. |

Вызывает функцию обратного вызова с заданными аргументами. Метод возвращает результат выполнения функции обратного вызова.

### Методы профилирования

Эти методы позволяют измерять время выполнения произвольного участка кода, а также получать информацию о размере выделенной в процессе работы скрипта памяти.

### **pStart()**

```php
public static void pStart(string $key)
```

||||
| -------- | ------ | --------------------------------------------------- |
| **$key** | string | уникальный идентификатор профилируемого блока кода. |

Запоминает текущее время, соответствующее началу выполнения блока кода.

### **pStop()**

```php
public static float pStop(string $key)
```

||||
| -------- | ------ | --------------------------------------------------- |
| **$key** | string | уникальный идентификатор профилируемого блока кода. |

Возвращает время выполнения блока кода (в секундах) по его идентификатору. Если с заданным идентификатором не связан никакой блок кода, то метод вернёт FALSE.

### **getExecutionTime()**

```php
public static float getExecutionTime()
```

Возвращает время выполнения скрипта в секундах. Началом выполнения скрипта считается первый вызов метода **init()**.

### **getRequestTime()**

```php
public static float getRequestTime()
```

Возвращает время от начала запроса к серверу до текущего момента времени.

### **getMemoryUsage()**

```php
public static integer getMemoryUsage()
```

Возвращает реальное количество памяти в байтах, которое было выделено PHP скрипту на на данный момент.

### **getPeakMemoryUsage()**

```php
public static integer getPeakMemoryUsage()
```

Возвращает реальный максимальный объем памяти в байтах, который был выделен PHP скрипту.

### Методы для хранения глобальных данных.

Комбинация этих методов является реализацией шаблона проектирования Registry - глобального пула общедоступных объектов различных типов.

### **all()**

```php
public static array all()
```

Возвращает ассоциативный массив глобальных объектов. Ключами этого массива являются идентификаторы объектов, а значениями - сами объекты. 

### **get()**

```php
public static mixed get(string $key)
```

||||
| -------- | ------ | --------------------------------------------- |
| **$key** | string | уникальный идентификатор глобального объекта. |

Возвращает ранее сохранённый глобальный объект или NULL, если объект с таким идентификатором не существует.

### **set()**

```php
public static void set(string $key, mixed $value)
```

||||
| -------- | ------ | --------------------------------------------- |
| **$key** | string | уникальный идентификатор глобального объекта. |
| **$value** | mixed | значение глобального объекта. |

Сохраняет данные ассоциированные с некоторым идентификатором в глобальном хранилище объектов.

### **has()**

```php
public static boolean has(string $key)
```

||||
| -------- | ------ | --------------------------------------------- |
| **$key** | string | уникальный идентификатор глобального объекта. |

Возвращает TRUE, если объект с заданным идентификатором существует и FALSE в противном случае.

### **remove()**

```php
public static void remove(string $key)
```

||||
| -------- | ------ | --------------------------------------------- |
| **$key** | string | уникальный идентификатор глобального объекта. |

Удаляет глобальный объект ассоциированный с заданным идентификатором.

### Методы перехвата и обработки ошибок

Эти методы позволяют перехватывать все виды ошибок и исключений, а также управлять реакцией фрэймворка на эти исключения.

### **errorHandling()**

```php
public static void errorHandling(boolean $enable = true, integer $errorLevel = null)
```

||||
| ----------- | ------- | ----------------------------------------------------- |
| **$enable** | boolean | определяет включён ли режим перехвата ошибок или нет. |
| **$errorLevel** | integer | уровень чувствительности к ошибкам. |

Включает или отключает перехват ошибок, а также устанавливает уровень чувствительности к ошибкам. Если первый параметр равен TRUE, любая ошибка в скрипте будет вызывать исключение, которое автоматически перехватывается и обрабатывается фрэймворком. Второй аргумент задаёт уровень чувствительности к ошибкам. Если этот параметр не определён, то будет использоваться уровень чувствительности определённый в файле php.ini

### **isErrorHandlingEnabled()**

```php
public static boolean isErrorHandlingEnabled()
```

Возвращает TRUE, если режим перехвата ошибок включён и FALSE в противном случае.

### **error()**

```php
public static string error(string|object $class, string $token, mixed $var1, mixed $var2, ...)
```

||||
| ---------- | -------------- | ------------------------------- |
| **$class** | string, object | класс содержащий шаблон ошибки. |
| **$token** | string | токен ошибки, т.е. имя константы некоторого класса, значением которой является шаблон ошибки. |
| **$var1**, **$var2**, ... | mixed | параметры шаблона ошибки. |

Генерирует сообщение об ошибке по заданному токену ошибки. Параметры (переменные) шаблона ошибки задаются внутри шаблона с помощью специальной конструкции: [{var}]. Замена переменных шаблона происходит слева направо.

Рассмотрим три основных случая в зависимости от переданных аргументов.
- Токен ошибки не является константой класса и представляет собой обычную строку шаблона ошибки. В этом случае имя класса является пустой строкой или равно FALSE. Например:
  
  ```php
  // Выведет 'Simple error template: 1, 2';
  echo CB::error(false, 'Simple error template: [{var}], [{var}]', 1, 2);
  ```
- Токен ошибки - имя константы класса. Первый параметр - объект заданного класса. Например:
  ```php
  class A
  {
    const ERR_1 = '[{var}] error template[{var}]';
  }

  $a = new A;

  // Выведет 'Test error template! (Token: A::ERR_1)'
  echo CB::error($a, 'ERR_1', 'Test', '!');
  ```

- Токен ошибки - имя константы класса. Первый параметр - имя класса. Например:
  ```php
  class A
  {
    const ERR_1 = '[{var}] error template[{var}]';
  }

  $a = new A;

  // Покажет 'Test error template! (Token: A::ERR_1)'
  echo CB::error('A', 'ERR_1', 'Test', '!');

  // Также возможна более компактная форма записи (с тем же результатом). 
  echo CB::error('A::ERR_1', 'Test', '!');
  ```

### **exception()**

```php
public static void exception(Exception $e)
```

||||
| ------ | --------- | ------------------ |
| **$e** | Exception | объект исключения. |

Завершает скрипт и в случае если режим отладки включён показывает информацию о возникшем исключении. Если режим отладки выключен метод покажет уведомление о возникшей ошибки, без детальной информации о ней.

> За управление режимом отладки отвечает булевый конфигурационный параметр **debugging**.

### **analyzeException()**

```php
public static array analyzeException(Exception $e)
```

||||
| ------ | --------- | ------------------ |
| **$e** | Exception | объект исключения. |

Возвращает детальную информацию о заданном исключении в виде ассоциативного массива.
 
### **ecode()**

```php
public static string ecode(string $code)
```

||||
| --------- | ------ | ------------------ |
| **$code** | string | некоторый PHP код. |

Сохраняет переданную строку PHP кода для дальнейшего анализа ошибок, которые могут произойти при выполнении этого кода посредством оператора **eval**. Метод возвращает то же значение, что и принимает в качестве аргумента.

В течении процесса разработки возникают ситуации когда вам необходимо выполнить некоторый PHP код во время выполнения скрипта. Обычно для этого используют оператор **eval**. Однако перехват ошибок в коде выполняемом через этот оператор затруднён. Для получения точной информации о месте ошибки и предназначен метод **ecode()**. Всё что вам нужно это совместить вызовы метода **ecode()** и оператора **eval**. Пример:

```php
eval(Aleph::ecode("echo 'Hello World!';"));
```

### **fatal()**

```php
public static void fatal()
```

Обнаруживает фатальные ошибки и ошибки парсинга. Этот метод автоматически вызывается когда скрипт завершает свою работу.

## Общедоступные нестатические методы ##

### Методы конфигурирования

Эти методы предназначены для загрузки конфигурационных файлов приложения, а также для доступа к конфигурационным данным.

### **setConfig()**

```php
public self|array setConfig(string|array $data, string $section = null, boolean $replace = false)
```

||||
| --------- | ------------- | --------------------------------------------------------------------------------- |
| **$data** | string, array | путь к конфигурационному файлу, или ассоциативный массив конфигурационных данных. |
| **$section** | string | имя секции конфигурационного файла (ключ массива конфигурационных данных). |
| **$replace** | boolean | определяет, следует ли заменить существующие данные новыми. |

Загружает конфигурационные данные из файла или из ассоциативного массива. Второй параметр метода определяет название секцию (ключа ассоциативного массива) в которую будут загружены конфигурационные данные. Если вы хотите перезаписать существующие конфигурационные данные, параметр **$replace** должен быть TRUE.

Поддерживаются конфигурацинные файлы двух форматов: INI и PHP. Типичная структура конфигурационного PHP файла:
```php
<?php

return [
  'var1' => 'val1',
  'var2' => 'val2',
  ...,
  'section1' => [
    'var1' => 'val1'
    'var2' => 'val2',
    ...
  ],
  'section2' => [
    'var1' => 'val1'
    'var2' => 'val2',
    ...
  ],
  ...
];
```

Типичная структура конфигурационного INI файла:
```php
var1 = "val1"
var2 = "val2"
...

[section1]
var1 = "val1"
var2 = "val2"
...

[section2]
var1 = "val1"
var2 = "val2"
...
```

Следующий пример иллюстрирует использование метода:
```php
$cb = Aleph::getInstance();
// загружает конфигурационные данные из файла.
$cb->setConfig('/path/to/config/file.php');
// загружает конфигурационные данные в секцию "foo".
$cb->setConfig(['var1' => 'val1', 'var2' => 'val2'], 'foo');
// заменяет данные из секции "foo" новыми данными из конфигурационного файла.
$cb->setConfig('/path/to/config/file.ini', 'foo', true);
```

### **getConfig()**

```php
public mixed getConfig(string $section = null)
```

||||
| ------------ | ------ | ----------------------------------------------------------------- |
| **$section** | string | имя секции (ключ ассоциативного массива конфигурационных данных). |

Если **$section** равен NULL, то метод вернёт все конфигурационные данные. В противном случае возвращается содержимое заданной конфигурационной секции (подмассив конфигурационных данных). Если секции с заданным именем не существует, метод вернёт NULL.

Допустим у нас есть следующий INI файл:
```php
debugging = 1
logging   = 1

[cache]
directory     = "cache"
gcProbability = 33.333

[foo]
var1 = "val1"
var2 = "val2"
```

Тот же файл, но на PHP:
```php
<?php

return [
  'debugging' => 1,
  'logging' => 1,
  'cache' => [
    'directory' => 'cache',
    'gcProbability' => 33.333
  ],
 'foo' => [
    'var1' => 'val1',
    'var2' => 'val2'
  ]
];
```

Следующий пример поясняет использование метода:
```php
$cb = Aleph::getInstance();
$foo = $cb->getConfig('foo');  // $foo содержит данные из "foo" секции: ['var1' => 'val1', 'var2' => 'val2']
$foo = $cb->getConfig('test'); // $foo содержит NULL.
$foo = $cb->getConfig();       // $foo содержит все конфигурационные данные.
```

### **offsetSet()**

```php
public void offsetSet(mixed $var, mixed $value)
```

||||
| -------- | ----- | -------------------------------------------------------------------------------------- |
| **$var** | mixed | имя конфигурационной переменной (ключ ассоциативного массива конфигурационных данных). |
| **$value** | mixed | значение конфигурационной переменной. |

Добавляет новую конфигурационную переменную или изменяет значение существующей. Метод является частью реализации интерфейса **ArrayAccess**. Пример:
```php
// Получает экземпляр Aleph
$a = Aleph::getInstance();

// Добавляем переменную "foo"
$a['foo'] = 'test';
```

### **offsetGet()**

```php
public mixed offsetGet(mixed $var)
```

||||
| -------- | ----- | -------------------------------------------------------------------------------------- |
| **$var** | mixed | имя конфигурационной переменной (ключ ассоциативного массива конфигурационных данных). |

Возвращает значение конфигурационной переменной по её имени. Если переменной с таким именем не существует, метод вернёт NULL. Метод является частью реализации интерфейса **ArrayAccess**. Пример:
```php
// Получает экземпляр Aleph
$a = Aleph::getInstance();

// Получает значение переменной "foo"
echo $a['foo'];
```

### **offsetExists()**

```php
public boolean offsetExists(mixed $var)
```

||||
| -------- | ----- | -------------------------------------------------------------------------------------- |
| **$var** | mixed | имя конфигурационной переменной (ключ ассоциативного массива конфигурационных данных). |

Возвращает TRUE, если конфигурационная переменная существует и её значение не равно NULL, и FALSE в противном случае. Метод является частью реализации интерфейса **ArrayAccess**. Пример:
```php
// Получает экземпляр Aleph
$a = Aleph::getInstance();

// Проверяет существует ли переменная "foo" или нет.
var_dump(isset($a['foo']));
```

### **offsetUnset()**

```php
public void offsetUnset(mixed $var)
```

||||
| -------- | ----- | -------------------------------------------------------------------------------------- |
| **$var** | mixed | имя конфигурационной переменной (ключ ассоциативного массива конфигурационных данных). |

Удаляет конфигурационную переменную по её имени. Метод является частью реализации интерфейса **ArrayAccess**. Пример:
```php
// Получает экземпляр Aleph
$a = Aleph::getInstance();

// Удаляет переменную "foo"
unset($a['foo']);
```

### Методы для загрузки классов

Эти методы предназначены для управления загрузчиком классов, а также для явного подключения классов.

### **createClassMap()**

```php
public integer createClassMap()
```

Searches classes according to the configuration settings and creates the class map file. The method returns the number of the all found classes.

### **setClassMap()**

```php
public void setClassMap(array $classes, string $classmap = null)
```

||||
| ------------ | ----- | ---------------------------------------------------------------------------------------------- |
| **$classes** | array | ассоциативный массив, ключами которого являются названия классов в нижнем регистре, а значениями - пути к файлам, содержащих эти классы. |
| **$classmap** | string | путь к файлу карты классов. |

Создаёт новую карту классов или переопределяет существующую.

### **getClassMap()**

```php
public array getClassMap()
```

Возвращает карту классов, которая представляет собой ассоциативный массив, ключами которого являются названия классов в нижнем регистре, а значениями - пути к файлам, содержащим эти классы. Если карта классов не установлена, метод вернёт пустой массив.

### **loadClass()**

```php
public boolean loadClass(string $class)
```

||||
| ---------- | ------ | ------------------------ |
| **$class** | string | имя класса для загрузки. |

Ищет требуемый класс и включает его в скрипт. Возвращает FALSE если заданных класс не существует и TRUE в противном случае.

### Дополнительные методы

Позволяют получать (или устанавливать) экземпляры наиболее часто используемых классов.

### **setCache()**

```php
public void setCache(Aleph\Cache\Cache $cache)
```

||||
| ---------- | ----------------- | ------------------- |
| **$cache** | Aleph\Cache\Cache | объект кэширования. |

Устанавливает объект кэширования, который будет использован по умолчанию в других классах фрэймворка.

### **getCache()**

```php
public Aleph\Cache\Cache getCache()
```

Возвращает объект кэширования, который по умолчанию используется для кэширования данных другими классами фрэймворка. Если этот объект не был установлен методом **setCache()**, то но будет создан согласно конфигурационным параметрам кэширования.

### **getRequest()**

```php
public Aleph\Net\Request getRequest()
```

Возвращает экземпляр класса **Aleph\Net\Request**, который содержит информацию о текущем HTTP запросе.

### **getResponse()**

```php
public Aleph\Net\Response getResponse()
```

Возвращает объект класса **Aleph\Net\Response**, который содержит информацию об ответе сервера на текущий HTTP запрос.

### **getRouter()**

```php
public Aleph\Net\Router getRouter()
```

Возвращает экземпляр маршрутизатора.